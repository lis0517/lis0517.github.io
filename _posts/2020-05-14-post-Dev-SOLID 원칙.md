---
layout: post
title: "Dev : SOLID 원칙"

categories:
  - Dev
tags:
  - Knowledge
---

## SOLID 원칙에 대하여  
***    
 
### SRP (Single Responsibiliy Principle, 단일 책임 원칙)  
  
```
객체는 단 하나의 책임(기능)만 가져야 한다.  
```
  
객체지향적으로 설계할 때는 응집도는 높게 결합도는 낮게 설계하는 것이 좋다.  

- 응집도 : 한 프로그램의 요소가 얼마나 뭉쳐있는지, 구성 요소들 사이의 응집력  
- 결합도 : 프로그램 구성 요소들 사이가 얼마나 의존적인지를 말함  

ex) 계산기 객체가 있을 때, 계산기 객체의 책임은 사칙 연산을 담당하는 것이다.  
그런데 이 곳에 TV 켜기 기능과 알람 기능을 추가하면 SRP 원칙에 위배된다.  

***  

### OCP (Open - Closed Principle, 개방 폐쇄 원칙)  
  
```
기존의 코드는 변경하지않으면서(closed), 기능을 추가할 수 있도록(open) 설계가 되어야한다.    
```
  
즉, 확장에 대해서는 개방적이고 수정에 대해서는 폐쇄적이라는 의미를 갖는다.

ex) 캡슐화를 통해 기능을 인터페이스에 정의하는 것    

***  
  
### LSP (Liskov Substitution Principle, 리스코프 치환 원칙)  
  
```
자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수정할 수 있어야한다. 
```
  
자식 클래스가 부모 클래스를 대체하기 위해서는 부모의 기능에 대해 오버라이드되도록 하지않으면 된다.  
즉, 자식 클래스는 부모의 책임을 무시하거나 재정의하지않고 확장만 수행해야 LSP 원칙에 어긋나지않는다.    

***  
  
### ISP (Interface Segregation Principle, 인터페이스 분리 원칙)  
  
```
자신이 사용하지않는 인터페이스는 구현하지않는다.  
```
  
SRP가 객체 단일 책임을 뜻한다면 ISP는 인터페이스의 단일 책임을 뜻한다.  

ex) 인터페이스의 주요 기능을 하나씩 둔 뒤, 클래스에서 여러 인터페이스를 구현하도록 한다.  

***  
  
### DIP (Dependency Inversion Principle, 의존 역전 원칙)  
  
```
객체들이 서로 주고 받을 때 의존 관계가 형성되는데, 이때 객체들은 나름대로 원칙을 갖고 정보를 주고 받아야한다.   
```
  
여기서 원칙이란 추상성이 낮은 클래스보다 추상성이 높은 클래스와 의존 관계를 맺어야한다는 것을 의미한다.  
일반적으로 인터페이스를 활용하면 이 원칙을 지킬 수 있다.  

ex) Client는 Pistol, Rifle, Shotgun의 Shot 메서드에 직접 접근할 필요없이 Gun(interface)의 Shot 메서드를 호출하여 DIP 원칙을 지킬 수 있다.  

